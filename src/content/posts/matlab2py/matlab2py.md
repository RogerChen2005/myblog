---
title: "利用Matlab开发PyModule: a C/C++ approach"
published: 2025-12-07
description: Matlab函数可以直接转为C/C++源码，我们可以进而将Matlab中编写得到的函数亦或是求解得到的符号表达式应用到其他语言编写的工程中
tags:
  - 杂谈
category: 技术分享
draft: false
---
:::note
在开始之前，你需要准备以下环境：
- Matlab
- Matlab Coder
- MSVC或者其他C/C++编译器
- Python
:::

## 从 Matlab 函数生成 C/C++ 代码

我们需要用到 Matlab 的 Matlab Coder 插件 [文档](https://ww2.mathworks.cn/help/coder/ref/codegen.html "文档")

用法为：

```matlab
codegen options function
```

### 编译类型

Codegen 有多种生成目标 [文档](https://ww2.mathworks.cn/help/coder/ug/build-setting-configuration.html "配置代码生成和编译设置")

- **MEX**：Codegen 默认生成的就是MEX函数，相当于Python的拓展，将Matlab编译成一个二进制的库，但是因为仍然基于Matlab的API，所以仍然只能在Matlab中使用，我们的目标是编译为Python模块，所以我们不能用默认配置。
- **完全剥离Matlab依赖的纯C/C++代码**：这个就是我们需要编译目标，有三种生成目标
	- `-config:lib`：只生成代码
	- `-config:dll`：生成Windows平台的动态链接库
	- `-config:exe`：生成Windows平台的可执行程序
	我们只生成代码即可

### 输入参数配置

matlab 是弱类型语言，需要指定输入参数的类型才可以转化为 C/C++代码

1. 在函数的Arguments块中配置，示例：

```matlab
function y = mcadd(u,v)
arguments %arguments块中定义了输入参数的大小和类型
    u (1,4) double
    v (1,1) double
end
y = u + v;
end
```

2. 在 codegen 命令中配置

添加`-args`开关，例如在上例中，我们可以通过以下命令生成

```matlab
codegen mcadd -args {[0 0 0 0],0}
```

也可以传入定义的变量

```matlab
u_example = zeros(1,4,'uint16');
v_example = 0;
codegen mcadd -args {u_example,v_example}
```

### 例子：一个复杂的符号表达式

POV：你使用Matlab计算了一个6轴机器人的雅克比矩阵，发现仿真环境用是Python，天塌了。

先转为独立的 Matlab 函数（去除符号项），利用 `matlabFunction`函数

```matlab
syms th_vec [1 6]

matlabFunction(Jacob_matrix, 'File', 'Jacob_function.m', 'Vars', {th_vec});
```

这里`Jacob_function.m`是输出的文件名`Jacob_matrix`是要转化的表达式，生成的函数

```matlab
function Jacob_matrix = Jacob_function(in1)
%Jacob_function
% Jacob_matrix_with_offset = Jacob_function(IN1)
% This function was generated by the Symbolic Math Toolbox version 25.2.
% 2025-11-16 20:31:04
th_vec1 = in1(:,1);
th_vec2 = in1(:,2);
th_vec3 = in1(:,3);
th_vec4 = in1(:,4);
th_vec5 = in1(:,5);
t2 = cos(th_vec1);
t3 = cos(th_vec3);
t4 = sin(th_vec1);
t5 = sin(th_vec3);
t6 = th_vec2+th_vec3+th_vec4;
t7 = -th_vec5;
t11 = pi./2.0;
t8 = cos(t6);
t9 = sin(t6);
t10 = -t4;
t12 = -t11;
t13 = t11+th_vec4;
t14 = t11+th_vec5;
t15 = t12+th_vec2;
t16 = cos(t13);
t17 = cos(t14);
t18 = sin(t13);
t19 = sin(t14);
t20 = t8.*7.7e+1;
t21 = t9.*7.7e+1;
t29 = t6+t14;
t32 = t6+t7+t12;
t22 = cos(t15);
t23 = sin(t15);
t24 = t15+th_vec3;
t27 = -t20;
t28 = -t21;
t30 = sin(t29);
t35 = sin(t32);
t39 = t9.*t19.*(1.71e+2./2.0);
t25 = cos(t24);
t26 = sin(t24);
t31 = t23.*1.85e+2;
t37 = t30.*(1.71e+2./4.0);
t40 = -t39;
t41 = t35.*(1.71e+2./4.0);
t33 = t25.*1.7e+2;
t34 = t26.*1.7e+2;
t38 = -t37;
t42 = t16.*t25.*7.7e+1;
t43 = t18.*t26.*7.7e+1;
t45 = t18.*t25.*(1.71e+2./2.0);
t46 = t16.*t26.*(1.71e+2./2.0);
t47 = t20+t40;
t36 = -t33;
t44 = -t42;
t48 = t27+t34+t39;
t49 = t45+t46;
t50 = t19.*t49;
t51 = t31+t34+t43+t44+t50;
mt1 = [t2.*-2.3e+1+t2.*t17.*(1.71e+2./2.0)-t4.*t22.*1.85e+2-t3.*t4.*t22.*1.7e+2-t4.*t8.*t19.*(1.71e+2./2.0)+t4.*t5.*t23.*1.7e+2-t4.*t16.*t26.*7.7e+1-t4.*t18.*t25.*7.7e+1,t4.*-2.3e+1+t4.*t17.*(1.71e+2./2.0)+t2.*t22.*1.85e+2+t2.*t3.*t22.*1.7e+2+t2.*t8.*t19.*(1.71e+2./2.0)-t2.*t5.*t23.*1.7e+2+t2.*t16.*t26.*7.7e+1+t2.*t18.*t25.*7.7e+1,0.0,0.0,0.0,1.0,-t2.*t51,t10.*t51,t22.*-1.85e+2+t28+t36+t38+t41,t10,t2,0.0,-t2.*t48,t10.*t48,t28+t36+t38+t41,t10,t2,0.0,t2.*t47,t4.*t47,t28+t38+t41,t10,t2,0.0,t4.*t19.*(-1.71e+2./2.0)+t2.*t8.*t17.*(1.71e+2./2.0)];
mt2 = [t2.*t19.*(1.71e+2./2.0)+t4.*t8.*t17.*(1.71e+2./2.0),t38-t41,t2.*t9,t4.*t9,t8,0.0,0.0,0.0,t4.*t17+t2.*t8.*t19,-t2.*t17+t4.*t8.*t19,-t9.*t19];
Jacob_matrix = reshape([mt1,mt2],6,6);
end
```

随后，这个纯 Matlab 函数就可以通过 codegen 来进行代码生成了

```matlab
example_params = zeros(1, 6);
codegen Jacob_function.m -args {example_params} -config:lib -report
```

现在在 `./codegen/lib/Jacob_function` 中即可找到生成的代码了，如果提示缺少编译器的话，在MATLAB的附加功能中安装 `MATLAB Support for MinGW-w64 C/C++/Fortran Compiler` 即可

## 从 C/C++ 代码编译 PyModule

我们利用Pybind11来进行绑定，[文档](https://pybind11.readthedocs.io/en/stable/index.html "pybind11 documentation")，需要先安装包：

```sh
pip install pybind11
```
### （可选）配置编辑器路径

如果你和我一样希望IDE有自动的代码提示和纠错，那么你需要添加一些IncludePath，便于代码编辑器识别，我这里使用的是Visual Studio Code。

以下头文件路径需要被包含：

```c
"Python_Path\\Lib\\site-packages\\pybind11\\include",
"Python_Path\\include",
"${workspaceFolder}\\codegen\\lib\\Jacob_function",
"MATLAB_Path\\R2025b\\extern\\include"
```

需要将上述的 `Python_Path` 替换成你的计算机中 Python 的安装路径 `MATLAB_Path` 替换成你的计算机中 MATLAB 的安装路径。

### 封装 C/C++ 代码

现在，我们需要在根目录下创建一个函数来对C/C++函数进行包封装，这个过程就是在对接Python的API，将C/C++的数据结构转为Python的数据结构

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <vector>

extern "C" {
    #include "Jacob_function.h"
    #include "Jacob_function_initialize.h"
    #include "Jacob_function_terminate.h"
}

namespace py = pybind11;

// 这是我们的 C++ 包装函数，它将被暴露给 Python
py::array_t<double> py_Jacob(py::array_t<double> theta_array) {
    py::buffer_info buf_temp = theta_array.request();
    if (buf_temp.ndim != 1 || buf_temp.shape[0] != 6) {
        throw std::runtime_error("Input should be a 1D array of 6 elements");
    }

    double *theta_ptr = static_cast<double *>(buf_temp.ptr);
    double theta[6];
    
    for (int i = 0; i < 6; ++i) {
        theta[i] = theta_ptr[i];
    }

    double c_out_buffer[36];
    Jacob_function(theta, c_out_buffer);

    // 创建一个 6x6 的 NumPy 数组
    // 注意：py::array_t 默认创建的是行优先数组，需要进行转置
    auto py_result_array = py::array_t<double>({6, 6});

    // 将 C (列优先) 数据复制并转置到 Python (行优先) 数组中
    py::buffer_info buf = py_result_array.request();
    double *py_data_ptr = static_cast<double *>(buf.ptr);

    // 进行转置
    for (int i = 0; i < 6; ++i) {
        for (int j = 0; j < 6; ++j) {
            py_data_ptr[i * 6 + j] = c_out_buffer[j * 6 + i];
        }
    }

    return py_result_array;

}

// 定义模块
PYBIND11_MODULE(robotic, m) {
    m.doc() = "pybind11 wrapper for MATLAB codegen robotic functions";

    // 在模块导入时，调用 C 库的初始化函数
    Jacob_function_initialize();

    // 绑定 Jacob 雅可比矩阵函数
    m.def("Jacob", &py_Jacob, "Calculate the 6x6 Jacobian Matrix",
        py::arg("theta"));
        
    // 在 Python 退出时调用
    m.def("terminate", []() {
        Jacob_function_terminate();
    }, "Terminate all MATLAB-generated libraries");
}
```

这里需要注意的是，NumPy中的数据是优先行存储的，而MATLAB生成的代码的矩阵是优先列存储的，所以需要进行转置

### 生成 PyModule

```python
from setuptools import setup
from pybind11.setup_helpers import Pybind11Extension, build_ext

import os
import numpy
import pybind11

# 定义路径
CODEGEN_DIR = os.path.join('codegen', 'lib', 'Jacob_function')
MATLAB_DIR = "MATLAB_Path\\R2025b\\extern\\include"

# 2. 定义模块
ext_modules = [
    Pybind11Extension(
        "robotic",  # 这个就是Python `import` 时用的名字
        ["wrapper.cpp"],        # 封装好的C++文件

        include_dirs=[
            pybind11.get_include(),
            numpy.get_include(),
            CODEGEN_DIR,
            MATLAB_DIR
        ],

        # 告诉链接器去哪里找 .lib / .so 文件
        library_dirs=[
            CODEGEN_DIR,
        ],

        # 告诉链接器要链接哪个库
        libraries=[
            "Jacob_function",
            "vcomp",
        ],

        runtime_library_dirs=[
            os.path.abspath(CODEGEN_DIR),
        ] if os.name != 'nt' else [],

        # (可选) 启用 C++17 和 OpenMP
        extra_compile_args=["/std:c++17", "/openmp"] if os.name == 'nt' else ["-std=c++17", "-fopenmp"],
        extra_link_args=["/openmp"] if os.name == 'nt' else ["-fopenmp"],
    ),
]

setup(
    name="robotic_module",
    version="1.0.0",
    description="Python wrapper for MATLAB Coder Jacobian",
    ext_modules=ext_modules,
    cmdclass={"build_ext": build_ext},
    zip_safe=False,
    python_requires=">=3.7",
)
```

需要将`MATLAB_Path`替换成实际上的MATLAB安装路径，需要注意的是，在`PYBIND11_MODULE(robotic, m)` 中定义的模块名称，和`Pybind11Extension("robotic",...args)` 中定义的模块名称需要相同，不然会报错（别问，问就是就是遇到过这个问题:( ）

### 编译模块

运行`setup.py`，会自动编译生成Python模块

```sh
python setup.py build_ext
```

看到以下输出，说明生成就成功了

```
... 上面还有很多，这里省略
  正在创建库 build\temp.win-amd64-cpython-313\Release\robotic.cp313-win_amd64.lib 和对象 build\temp.win-amd64-cpython-313\Release\robotic.cp313-win_amd64.exp
正在生成代码
已完成代码的生成
```

注意，每次只能生成当前Python版本的，例如我这里用的是Python3.12，生成的也只能是Python3.12的。

## 在 Python 中使用

```python
import robotic
import numpy as np

angles = np.array([0.1, 0.5, 0.3, 0.0, 1.0, 0.0])
J = robotic.Jacob(angles)

print("Jacobian Matrix:\n", J)
```

直接 import 即可，但是注意需要和编译的 `robotic.cp312-win_amd64.pyd`在同一路径（或者自己做路径依赖），然后版本号要一样，上述的库就只能在 `Win64` 和 `CPython3.12`的环境中运行，如果用 `CPython3.13` 的话就会import报错